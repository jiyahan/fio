<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>fio</title>
    <style type="text/css">
      body {
        background-color: #6080a0;
        color: #ffffff;
      }
      h1 {
        text-align: center;
        font-size: 1.5em;
        font-weight: bold;
      }
      h2 {
        text-align: center;
        font-size: 1.4em;
        font-weight: bold;
      }
      p {
        text-align: justify;
      }
      .main {
        margin-left: auto;
        margin-right: auto;
        padding: .5ex 1ex .5ex 1ex;
        background-color: #e0e0e0;
        color: #000000;
        display: table;
      }
      .sections {
        margin-top: 0;
        padding-left: 2em;
      }
      .main > .sections {
        /* This is the header section for the whole module */
        margin-left: auto;
        margin-right: auto;
        margin-top: 0;
        padding: 1ex 1em 1ex 1em;
        background-color: #f0f0f0;
	color: #000000;
      }
      .decl, .desc {
        padding: .5ex 1ex .5ex 1ex;
        margin: 1ex 0 1ex 0;
      }
      .sections, dt.decl > p {
	/* We wrap dt.decl in a <p> so that the <dt> is allowed to expand to
	the width of the <dd>, otherwise the background will be truncated. Yes
	this is ugly but CSS is a bit crippled. */
        max-width: 45em;
      }
      dt.decl, dt.decl > p {
        margin-top: 0;
        margin-bottom: 0;
        text-align: left;
        font-size: 1.5em;
        font-weight: bold;
      }
      dd.decl {
        margin-top: 0;
      }
      .sections p:first-child, h4.sec + p {
        margin-top: 0;
      }
      .decl {
        background-color: #f0f0f0;
        color: #000000;
      }
      .decl .decl {
        background-color: #f8f8f8;
	color: #000000;
      }
      .decl .decl .decl {
        background-color: #ffffff;
        color: #000000;
      }
      dd dl {
        margin-left: 2em;
      }
      h3.memb {
        text-align: left;
        padding-left: 2em;
        font-size: 1em;
        font-weight: bold;
      }
      pre.d_code {
        padding: .5ex 1ex .5ex 1ex;
        border: 1px dotted black;
        background-color: #ffffc0;
	color: #000000;
      }
      h4.sec {
        margin-top: 0;
        margin-bottom: 0;
        text-align: left;
        font-size: 1em;
        font-weight: bold;
      }
      dl.params {
        margin-top: 0;
      }
      .paramname {
        margin-top: 0;
        margin-bottom: 0;
        padding-right: 1em;
        vertical-align: top;
        font-size: 1.1em;
        white-space: nowrap;
      }
    </style>
    
  </head>
  <body>
  
  <div class="main">
    
    <h1>Module: fio</h1>
    <!-- Generated by Ddoc from source/fio.d -->
</p><p>
<div class="modmemb">
    <h2>Details</h2>
    <dl><dt class="decl"><p><code><a name="stacksize"></a>@property int <u>stacksize</u>();
</code></p></dt>
<dd class="decl desc"><div class="sections"><p>Get stack size for new fibers. Default value is 64k.
</p>
</div>
</dd>
<dt class="decl"><p><code><a name="stacksize.2"></a>@property void <u>stacksize</u>(int <code><i>s</i></code>);
</code></p></dt>
<dd class="decl desc"><div class="sections"><p>Set stack size for new fibers
</p>
</div>
</dd>
<dt class="decl"><p><code><a name="MsgBox"></a>class <u>MsgBox</u>;
</code></p></dt>
<dd class="decl desc"><div class="sections"><p>Syncronization between fibers.
</p>
<h4 class="sec">Examples:</h4> <p><pre class="d_code">
globalLogLevel(LogLevel.info);
info(<span style="color:red">"Test msgBox"</span>);
makeApp((){
    <span style="color:blue">auto</span> box = <span style="color:blue">new</span> <u>MsgBox</u>;

    <span style="color:blue">auto</span> f1 = makeFuture((<span style="color:blue">int</span> arg){
            Variant msg = arg;
            info(<span style="color:red">"post 1st msg"</span>);
            box.post(msg);
            fioSleep(500.msecs);
            msg = arg + 1;
            info(<span style="color:red">"post 2nd msg"</span>);
            box.post(msg);
            info(<span style="color:red">"post empty msg"</span>);
            box.post();
        }, 1).start();
    <span style="color:blue">auto</span> f2 = makeFuture((){
            infof(<span style="color:red">"Wait for 1st msg"</span>);
            <span style="color:blue">auto</span> i = box.waitAndGet(1.seconds);
            infof(<span style="color:red">"Got msg int(%s)"</span>, i);
            <span style="color:blue">assert</span>(i == 1);
            infof(<span style="color:red">"Wait for 2nd msg"</span>);
            i = box.waitAndGet(1.seconds);
            <span style="color:blue">assert</span>(i == 2);
            infof(<span style="color:red">"Got msg int(%s)"</span>, i);
            <span style="color:blue">auto</span> e = box.waitAndGet();
            infof(<span style="color:red">"Got uninitialized value %s"</span>, e);
            info(<span style="color:red">"Check timeouts on waiting for msg"</span>);
            assertThrown(box.waitAndGet(1.seconds));
        }).start();
    <span style="color:blue">auto</span> t = tuple(f1,f2);
    t.waitAll(10.seconds);
});
runEventLoop();
info(<span style="color:red">"MsgBox tests ok"</span>);
</pre>
</p></div>
<h3 class="memb">Members:</h3>
  <dl><dt class="decl"><p><code><a name="MsgBox.post"></a>@trusted void <u>post</u>(in Variant <code><i>msg</i></code> = Variant.init);
</code></p></dt>
<dd class="decl desc"><div class="sections"><p>Post message to box.
</p>
<p><h4 class="sec">Parameters:</h4>
<code><i>msg</i></code> = data to <u>post</u>. Can be empty if you just need to wake up some fiber.

</p>
<p><h4 class="sec">Return:</h4>
void</p>
</div>
</dd>
<dt class="decl"><p><code><a name="MsgBox.waitAndGet"></a>@trusted Variant <u>waitAndGet</u>(Duration <code><i>timeout</i></code> = 0.seconds);
</code></p></dt>
<dd class="decl desc"><div class="sections"><p>Wait and get message from box
</p>
<p><h4 class="sec">Parameters:</h4>
<code><i>timeout</i></code> = how long to wait

</p>
<h4 class="sec">Returns:</h4> <p>message posted.
</p><p>

Can throw exception TimeoutException.</p>
</div>
</dd>
</dl>
</dd>
<dt class="decl"><p><code><a name="Daemon"></a>class <u>Daemon</u>(F, A...);
</code></p></dt>
<dd class="decl desc"><div class="sections"><p>Excecution unit that run in "background". You can't wait for its completion or get result.
</p>
<p>To run asyncronous code that will return any result use Future</p>
</div>
<h3 class="memb">Members:</h3>
  <dl><dt class="decl"><p><code><a name="Daemon.this"></a>pure @safe this(F <code><i>f</i></code>, A <code><i>a</i></code>);
</code></p></dt>
<dd class="decl desc"><div class="sections"><p>Constructor
</p>
<h4 class="sec">Parameters:</h4>
  <table class="params"><tr><td class="paramname"><code>F <code><i>f</i></code></code></td>
<td class="paramdesc"><p>function or generator</p></td></tr>
<tr><td class="paramname"><code>A <code><i>a</i></code></code></td>
<td class="paramdesc"><p>args to call <code><i>f</i></code></p></td></tr>
</table>
</div>
</dd>
<dt class="decl"><p><code><a name="Daemon.start"></a>auto <u>start</u>();
</code></p></dt>
<dd class="decl desc"><div class="sections"><p>You have to call <u>start</u>() method to <u>start</u> daemon running
</p>
<h4 class="sec">Parameters:</h4>
  <table class="params"></table>
<p><h4 class="sec">Return:</h4>
Daemon object (you can chain calls)</p>
</div>
</dd>
</dl>
</dd>
<dt class="decl"><p><code><a name="Future"></a>class <u>Future</u>(F, A...);
</code></p></dt>
<dd class="decl desc"><div class="sections"><p>Execution unit that run in "foreground" - you can wait for completion and get results
</p>
</div>
<h3 class="memb">Members:</h3>
  <dl><dt class="decl"><p><code><a name="Future.this"></a>pure nothrow @nogc @safe this(F <code><i>f</i></code>, A <code><i>a</i></code>);
</code></p></dt>
<dd class="decl desc"><div class="sections"><p>Constructor
</p>
<h4 class="sec">Parameters:</h4>
  <table class="params"><tr><td class="paramname"><code>F <code><i>f</i></code></code></td>
<td class="paramdesc"><p>function or generator</p></td></tr>
<tr><td class="paramname"><code>A <code><i>a</i></code></code></td>
<td class="paramdesc"><p>args to call <code><i>f</i></code></p></td></tr>
</table>
</div>
</dd>
<dt class="decl"><p><code><a name="Future.start"></a>@safe auto <u>start</u>();
</code></p></dt>
<dd class="decl desc"><div class="sections"><p>You have to call <u>start</u>() to <u>start</u> Future execution
</p>
</div>
</dd>
<dt class="decl"><p><code><a name="Future.get"></a>@property @safe auto <u>get</u>();
</code></p></dt>
<dd class="decl desc"><div class="sections"><p>Get return value of f when f completes.
</p>
</div>
</dd>
<dt class="decl"><p><code><a name="Future.ready"></a>@property @safe bool <u>ready</u>();
</code></p></dt>
<dd class="decl desc"><div class="sections"><p>Get completion status and result readiness
</p>
<p><h4 class="sec">Return:</h4>
True if task were started and were finished</p>
</div>
</dd>
<dt class="decl"><p><code><a name="Future.wait"></a>int <u>wait</u>(Duration <code><i>d</i></code> = 0.seconds);
</code></p></dt>
<dd class="decl desc"><div class="sections"><p>Wait for task completion. Also start task if you forget to call method start()
</p>
<h4 class="sec">Parameters:</h4>
  <table class="params"><tr><td class="paramname"><code>Duration <code><i>d</i></code></code></td>
<td class="paramdesc"><p>how long to <u>wait</u> (forewer by default)</p></td></tr>
</table>
<p><h4 class="sec">Return:</h4>
status of <u>wait</u> (SUCCESS or TIMEDOUT)</p>
</div>
</dd>
<dt class="decl"><p><code><a name="Future.waitAndGet"></a>@property auto <u>waitAndGet</u>(Duration <code><i>d</i></code> = 0.seconds);
</code></p></dt>
<dd class="decl desc"><div class="sections"><p>Wait for task completion and return result. Also start task if you forget to call method start()
</p>
<h4 class="sec">Parameters:</h4>
  <table class="params"><tr><td class="paramname"><code>Duration <code><i>d</i></code></code></td>
<td class="paramdesc"><p>how long to wait (forewer by default)</p></td></tr>
</table>
<p><h4 class="sec">Return:</h4>
result of f, or exceptioin ResultNotReady if result is not ready after timeout <code><i>d</i></code> expired.</p>
</div>
</dd>
</dl>
</dd>
<dt class="decl"><p><code><a name="makeFuture"></a>pure nothrow @safe auto <u>makeFuture</u>(F, A...)(F <code><i>f</i></code>, A <code><i>a</i></code>);
</code></p></dt>
<dd class="decl desc"><div class="sections"><p><u>makeFuture</u> create "Future" - execution unit that you
</p>
<p>can start, wait for completion and get result

</p>
<h4 class="sec">Parameters:</h4>
  <table class="params"><tr><td class="paramname"><code>F f</code></td>
<td class="paramdesc"><p>function or delegate to run</p></td></tr>
<tr><td class="paramname"><code>A a</code></td>
<td class="paramdesc"><p>args for calling f</p></td></tr>
</table>
<h4 class="sec">Examples:</h4> <p><pre class="d_code">
globalLogLevel(LogLevel.info);
info(<span style="color:red">"Test Future"</span>);
<span style="color:blue">new</span> fioTask((){
    <span style="color:blue">int</span> base = 1;
    <span style="color:blue">void</span> f0() {
    }
    <span style="color:blue">int</span> f1(<span style="color:blue">int</span> a) {
        <span style="color:blue">return</span> a;
    }
    <span style="color:blue">int</span> f2(<span style="color:blue">int</span> a, <span style="color:blue">int</span> b) {
        infof(<span style="color:red">"f2 sleep, wait %d seconds, please."</span>, a);
        fioSleep(dur!<span style="color:red">"seconds"</span>(a));
        <span style="color:blue">return</span> b+base;
    }
    <span style="color:blue">auto</span> t0 = <u>makeFuture</u>(&amp;f0).start();
    <span style="color:blue">auto</span> t1 = <u>makeFuture</u>(&amp;f1, 1).start();
    <span style="color:blue">auto</span> t2 = <u>makeFuture</u>(&amp;f2, 5, 1).start();
    <span style="color:blue">auto</span> t3 = <u>makeFuture</u>((string s) {
            <span style="color:blue">assert</span>(s == <span style="color:red">"hello"</span>);
        }, <span style="color:red">"hello"</span>).start();
    <span style="color:blue">auto</span> t = tuple(t0, t1, t2, t3);
    <span style="color:blue">assert</span>(t.waitAll(1.seconds) == [0,0,TIMEOUT,0]);
    info(<span style="color:red">"Future waitAll - ok"</span>);
    <span style="color:blue">auto</span> tasks = map!(a =&gt; <u>makeFuture</u>(&amp;f1, a).start)([1, 2, 3]).array();
    tasks ~= <u>makeFuture</u>(&amp;f1, 4).start;
    <span style="color:green">//fioSleep(1.seconds);
</span>    <span style="color:blue">assert</span>(tasks.map!(a =&gt; a.waitAndGet).array() == [1,2,3,4]);
    info(<span style="color:red">"Future waitAndGet - ok"</span>);
    <span style="color:blue">auto</span> d = makeDaemon(
            (<span style="color:blue">int</span> a) {
                infof(<span style="color:red">"Daemon got %d and return"</span>, a);
            }, 1
        ).start();
    stopEventLoop();
});
runEventLoop();
info(<span style="color:red">"Test Future! Done"</span>);
</pre>
</p></div>
</dd>
<dt class="decl"><p><code><a name="makeDaemon"></a>pure nothrow @safe auto <u>makeDaemon</u>(F, A...)(F <code><i>f</i></code>, A <code><i>a</i></code>);
</code></p></dt>
<dd class="decl desc"><div class="sections"><p><u>makeDaemon</u> create "Daemon" - execution unit that you
</p>
<p>can start but can't wait for completion or get result.
</p><p>

All you can do with daemons - wait when all daemons finish with call
</p><p>

waitForAllDaemons()

</p>
<h4 class="sec">Parameters:</h4>
  <table class="params"><tr><td class="paramname"><code>F f</code></td>
<td class="paramdesc"><p>function or delegate to run</p></td></tr>
<tr><td class="paramname"><code>A a</code></td>
<td class="paramdesc"><p>args for calling f</p></td></tr>
</table>
</div>
</dd>
<dt class="decl"><p><code><a name="makeApp"></a>auto <u>makeApp</u>(F, A...)(F <code><i>f</i></code>, A <code><i>a</i></code>);
</code></p></dt>
<dd class="decl desc"><div class="sections"><p><u>makeApp</u> create "Future" that
 will stop eventLoop when completed
</p>
<h4 class="sec">Parameters:</h4>
  <table class="params"><tr><td class="paramname"><code>F f</code></td>
<td class="paramdesc"><p>function or delegate to run</p></td></tr>
<tr><td class="paramname"><code>A a</code></td>
<td class="paramdesc"><p>args for calling f</p></td></tr>
</table>
<p><h4 class="sec">Return:</h4>
Nothing</p>
<h4 class="sec">Examples:</h4> <p><pre class="d_code">
globalLogLevel(LogLevel.info);
info(<span style="color:red">"Test makeApp"</span>);
<u>makeApp</u>((){
    <span style="color:blue">void</span> f0() {
        <span style="color:blue">auto</span> aa = [1:1];
    }
    <span style="color:blue">auto</span> t0 = makeFuture(&amp;f0).start();
    t0.wait();
});
runEventLoop();
info(<span style="color:red">"App finished"</span>);
</pre>
</p></div>
</dd>
<dt class="decl"><p><code><a name="waitForAllDaemons"></a>int <u>waitForAllDaemons</u>(Duration <code><i>timeout</i></code> = 0.seconds);
</code></p></dt>
<dd class="decl desc"><div class="sections"><p>wait(polling used) until all started daemon tasks finish
</p>
<h4 class="sec">Parameters:</h4>
  <table class="params"><tr><td class="paramname"><code>Duration <code><i>timeout</i></code></code></td>
<td class="paramdesc"><p>,how long to wait</p></td></tr>
</table>
<p><h4 class="sec">Return:</h4>
TIMEOUT or 0</p>
</div>
</dd>
<dt class="decl"><p><code><a name="waitAll"></a>int[] <u>waitAll</u>(W)(W <code><i>tasks</i></code>, Duration <code><i>d</i></code> = 0.seconds);
</code></p></dt>
<dd class="decl desc"><div class="sections"><p>Wait until all tasks in array finish
</p>
<h4 class="sec">Parameters:</h4>
  <table class="params"><tr><td class="paramname"><code>W tasks</code></td>
<td class="paramdesc"><p>range of objects, supporting wait()</p></td></tr>
<tr><td class="paramname"><code>Duration d</code></td>
<td class="paramdesc"><p>time to wait</p></td></tr>
</table>
<p><h4 class="sec">Return:</h4>
array of the 0(success) and TIMEOUT(failed to wait)</p>
</div>
</dd>
<dt class="decl"><p><code><a name="fioSleep"></a>void <u>fioSleep</u>(in Duration <code><i>d</i></code>);
</code></p></dt>
<dd class="decl desc"><div class="sections"><p>sleep for some duration.
</p>
<p>you have to use this sleep as it allow concurrency

</p>
<h4 class="sec">Parameters:</h4>
  <table class="params"><tr><td class="paramname"><code>Duration <code><i>d</i></code></code></td>
<td class="paramdesc"><p>duration</p></td></tr>
</table>
<p><h4 class="sec">Return:</h4>
void

</p>
<h4 class="sec">Examples:</h4> <p><pre style="display:inline;" class="d_inline_code"><u>fioSleep</u>(1.seconds)</pre></p>
</div>
</dd>
<dt class="decl"><p><code><a name="makeTCPListener"></a>auto <u>makeTCPListener</u>(F)(string <code><i>host</i></code>, ushort <code><i>port</i></code>, F <code><i>f</i></code>);
</code></p></dt>
<dd class="decl desc"><div class="sections"><p>Create TCPListener instance.
</p>
<p><h4 class="sec">Note:</h4>
1. Listener will accept connections only after call to method start().
</p><p>

2. After start() you may want to use method serve() to accept and serve requests
</p><p>

until method stop is called()

</p>
<h4 class="sec">Parameters:</h4>
  <table class="params"><tr><td class="paramname"><code>string host</code></td>
<td class="paramdesc"><p>interface to listen</p></td></tr>
<tr><td class="paramname"><code>ushort port</code></td>
<td class="paramdesc"><p>port to listen</p></td></tr>
<tr><td class="paramname"><code>F f</code></td>
<td class="paramdesc"><p>function or delegate to execute on each connectiom</p></td></tr>
</table>
<p><h4 class="sec">Return:</h4>
instance of class fioTCPListener</p>
</div>
</dd>
<dt class="decl"><p><code><a name="fioTCPListener"></a>class <u>fioTCPListener</u>(F);
</code></p></dt>
<dd class="decl desc"><div class="sections"><p>Incoming TCP connections handler
</p>
<p>Common</p>
</div>
<h3 class="memb">Members:</h3>
  <dl><dt class="decl"><p><code><a name="fioTCPListener.start"></a>auto <u>start</u>();
</code></p></dt>
<dd class="decl desc"><div class="sections"><p>Start accepting connections
</p>
<h4 class="sec">Returns:</h4> <p>this</p>
</div>
</dd>
<dt class="decl"><p><code><a name="fioTCPListener.serve"></a>auto <u>serve</u>();
</code></p></dt>
<dd class="decl desc"><div class="sections"><p>Implement loop (also start listening if not done yet).
</p>
<p><pre class="d_code">
<span style="color:blue">while</span> ( ! stopped ) { accept-and-handle;}

</pre>
</p>
</div>
</dd>
<dt class="decl"><p><code><a name="fioTCPListener.stop"></a>auto <u>stop</u>();
</code></p></dt>
<dd class="decl desc"><div class="sections"><p>Break serve() loop.
</p>
<p><h4 class="sec">Note:</h4>
Connection is not closed and still can accept (call close() to close socket)</p>
</div>
</dd>
<dt class="decl"><p><code><a name="fioTCPListener.fork"></a>auto <u>fork</u>(int <code><i>n</i></code>);
</code></p></dt>
<dd class="decl desc"><div class="sections"><p>Before call to start() you can <u>fork</u> Listener, it wil accept connectons
</p>
<p>in several processes. See forked_server in examples.
</p><p>

</p><p>


</p>
<h4 class="sec">Parameters:</h4>
  <table class="params"><tr><td class="paramname"><code>int <code><i>n</i></code></code></td>
<td class="paramdesc"><p>how many processes to <u>fork</u></p></td></tr>
</table>
<p><h4 class="sec">Return:</h4>
int 0 in parent, 1 in child</p>
</div>
</dd>
<dt class="decl"><p><code><a name="fioTCPListener.waitForForkedChilds"></a>auto <u>waitForForkedChilds</u>();
</code></p></dt>
<dd class="decl desc"><div class="sections"><p>Parent can call for forked childs
</p>
</div>
</dd>
<dt class="decl"><p><code><a name="fioTCPListener.close"></a>void <u>close</u>();
</code></p></dt>
<dd class="decl desc"><div class="sections"><p>stop listening and <u>close</u> socket.
</p>
</div>
</dd>
</dl>
</dd>
<dt class="decl"><p><code><a name="fioTCPConnection"></a>class <u>fioTCPConnection</u>;
</code></p></dt>
<dd class="decl desc"><div class="sections"><p>Handle connect(for outgoing connections),send,receive.
</p>
</div>
<h3 class="memb">Members:</h3>
  <dl><dt class="decl"><p><code><a name="fioTCPConnection.this"></a>this(Socket <code><i>so</i></code>);
</code></p></dt>
<dd class="decl desc"><div class="sections"><p>Constructor for pre-created sockets (accepted connection for example)
</p>
<h4 class="sec">Parameters:</h4>
  <table class="params"><tr><td class="paramname"><code>Socket <code><i>so</i></code></code></td>
<td class="paramdesc"><p>socket</p></td></tr>
</table>
</div>
</dd>
<dt class="decl"><p><code><a name="fioTCPConnection.this.2"></a>this(in string <code><i>host</i></code>, in ushort <code><i>port</i></code>, in Duration <code><i>timeout</i></code> = 0.seconds);
</code></p></dt>
<dd class="decl desc"><div class="sections"><p>Constructor
</p>
<p>Create socket, connect to remote end. You can find connection status using
</p><p>

connected() method
</p><p>

</p><p>


</p>
<h4 class="sec">Parameters:</h4>
  <table class="params"><tr><td class="paramname"><code>string <code><i>host</i></code></code></td>
<td class="paramdesc"><p><code><i>host</i></code> (ip or name to connect)</p></td></tr>
<tr><td class="paramname"><code>ushort <code><i>port</i></code></code></td>
<td class="paramdesc"><p><code><i>port</i></code> to connect</p></td></tr>
<tr><td class="paramname"><code>Duration <code><i>timeout</i></code></code></td>
<td class="paramdesc"><p>how long to wait for connection</p></td></tr>
</table>
</div>
</dd>
<dt class="decl"><p><code><a name="fioTCPConnection.close"></a>void <u>close</u>();
</code></p></dt>
<dd class="decl desc"><div class="sections"><p>Close socket
</p>
</div>
</dd>
<dt class="decl"><p><code><a name="fioTCPConnection.timedout"></a>const pure nothrow @property bool <u>timedout</u>();
</code></p></dt>
<dd class="decl desc"><div class="sections"><p>Last operation timeout status.
</p>
<p><h4 class="sec">Return:</h4>
<b>true</b> or <b>false</b></p>
</div>
</dd>
<dt class="decl"><p><code><a name="fioTCPConnection.connected"></a>const pure nothrow @property bool <u>connected</u>();
</code></p></dt>
<dd class="decl desc"><div class="sections"><p>Status of connection.
</p>
<p><h4 class="sec">Return:</h4>
<b>true</b> or <b>false</b></p>
</div>
</dd>
<dt class="decl"><p><code><a name="fioTCPConnection.error"></a>const pure nothrow @property bool <u>error</u>();
</code></p></dt>
<dd class="decl desc"><div class="sections"><p>Error state on socket
</p>
<p><h4 class="sec">Return:</h4>
<b>true</b> or <b>false</b></p>
</div>
</dd>
<dt class="decl"><p><code><a name="fioTCPConnection.send"></a>int <u>send</u>(const void[] <code><i>buff</i></code>, size_t <code><i>len</i></code>, in Duration <code><i>timeout</i></code> = 60.seconds);
</code></p></dt>
<dd class="decl desc"><div class="sections"><p>Send data from buffer or <code><i>timeout</i></code>.
</p>
<h4 class="sec">Parameters:</h4>
  <table class="params"><tr><td class="paramname"><code>void[] <code><i>buff</i></code></code></td>
<td class="paramdesc"><p>buffer with data</p></td></tr>
<tr><td class="paramname"><code>size_t <code><i>len</i></code></code></td>
<td class="paramdesc"><p>range to <u>send</u></p></td></tr>
<tr><td class="paramname"><code>Duration <code><i>timeout</i></code></code></td>
<td class="paramdesc"><p><code><i>timeout</i></code> for data sending</p></td></tr>
</table>
<p><h4 class="sec">Return:</h4>
number of transmitted bytes or ERROR</p>
</div>
</dd>
<dt class="decl"><p><code><a name="fioTCPConnection.send.2"></a>int <u>send</u>(const void[] <code><i>buff</i></code>, in Duration <code><i>timeout</i></code> = 60.seconds);
</code></p></dt>
<dd class="decl desc"><div class="sections"><p>Send data from buffer or <code><i>timeout</i></code>.
</p>
<h4 class="sec">Parameters:</h4>
  <table class="params"><tr><td class="paramname"><code>void[] <code><i>buff</i></code></code></td>
<td class="paramdesc"><p>data to <u>send</u></p></td></tr>
<tr><td class="paramname"><code>Duration <code><i>timeout</i></code></code></td>
<td class="paramdesc"><p><code><i>timeout</i></code> for data sending</p></td></tr>
</table>
<p><h4 class="sec">Return:</h4>
number of transmitted bytes or ERROR</p>
</div>
</dd>
<dt class="decl"><p><code><a name="fioTCPConnection.recv"></a>int <u>recv</u>(byte[] <code><i>buff</i></code>, in Duration <code><i>timeout</i></code> = 0.seconds, in Partial <code><i>partial</i></code> = Partial.yes, in string <code><i>__file__</i></code> = __FILE__, in size_t <code><i>__line__</i></code> = __LINE__);
</code></p></dt>
<dd class="decl desc"><div class="sections"><p>Receive data from connection.
</p>
<p>When any data received from socket level:
</p><p>

if <code><i>partial</i></code> is <b>true</b>, return immediately
</p><p>

else continue waiting for data.
</p><p>

if <code><i>timeout</i></code>:
</p><p>

return as many data as we can.
</p><p>

if error on socket:
</p><p>

return and set error state.

</p>
<h4 class="sec">Parameters:</h4>
  <table class="params"><tr><td class="paramname"><code>byte[] <code><i>buff</i></code></code></td>
<td class="paramdesc"><p>buffer to receive data to.</p></td></tr>
<tr><td class="paramname"><code>Duration <code><i>timeout</i></code></code></td>
<td class="paramdesc"><p>how long to wait data.</p></td></tr>
<tr><td class="paramname"><code>Partial <code><i>partial</i></code></code></td>
<td class="paramdesc"><p>if we allow to receive less data then buffer can accept.</p></td></tr>
</table>
<p><h4 class="sec">Return:</h4>
number of received bytes or ERROR (timedout or error on socket).
</p><p>

if socket closed - return 0</p>
</div>
</dd>
</dl>
</dd>
<dt class="decl"><p><code><a name="makeSignalHandler"></a>@safe auto <u>makeSignalHandler</u>(F)(int <code><i>sig</i></code>, F <code><i>f</i></code>, in string <code><i>file</i></code> = __FILE__, in size_t <code><i>line</i></code> = __LINE__);
</code></p></dt>
<dd class="decl desc"><div class="sections"><p>Create signal handler
</p>
<h4 class="sec">Parameters:</h4>
  <table class="params"><tr><td class="paramname"><code>int sig</code></td>
<td class="paramdesc"><p>signal number</p></td></tr>
<tr><td class="paramname"><code>F f</code></td>
<td class="paramdesc"><p>function or delegate - handler</p></td></tr>
</table>
<p><h4 class="sec">Return:</h4>
SignalHandler object</p>
<h4 class="sec">Examples:</h4> <p><pre class="d_code">
<span style="color:green">///
</span><span style="color:green">/// test Signal
</span><span style="color:green">///
</span><span style="color:blue">import</span> core.sys.posix.signal;
info(<span style="color:red">"Test Signal"</span>);
<span style="color:blue">bool</span>    signalled;
makeApp((){
    <span style="color:blue">auto</span> sig = <u>makeSignalHandler</u>(SIGINT, (<span style="color:blue">int</span> s){
        infof(<span style="color:red">"got signal %d"</span>, s);
        signalled = <span style="color:blue">true</span>;
    });
    <span style="color:blue">scope</span>(exit) {
        sig.restore();
    }
    fioSleep(1.seconds);
    kill(getpid(), SIGINT);
    fioSleep(1.seconds);
    <span style="color:blue">assert</span>(signalled);
});
runEventLoop();
info(<span style="color:red">"Test Signal done"</span>);
</pre>
</p></div>
</dd>
</dl>
  </div>

  </div>
  
  </body>
</html>
